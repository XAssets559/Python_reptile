# 正则表达式

## 基础1

### 全局匹配函数使用格式：

### re.compile(正则表达式).findall(源字符串)



普通字符	正常匹配

\n				匹配换行符

\t				 匹配换行符

\w			    匹配字母、数字、下划线

\W			   匹配除字母、数字、下划线

\d				匹配十进制数

\D				匹配除十进制数

\s				匹配空白字符

\S				匹配除空白字符

[ab89x]	  原子表，匹配ab89x中的任意一个

[^ab89x]	原子表，匹配除ab89x外的任意一个字符

*注意*：[]表示原子表。除最后两个，其余均是原子

### 案例1：

**注意**：得导入re模块：import re



## 基础2

.		匹配除换行符以外任意一个字符

^		匹配开始位置

$		匹配结束位置

'*'		前一个字符出现0\1\多次（默认贪婪，即尽可能多匹配）

？		前一个字符出现0\1次

'+'		前一个字符出现1\多次

{n}		前一个字符恰好出现n次

{n,}		前一个字符至少出现n次

{n,m}		前一个字符至少n次，至多m次

|			模式选择符或

()			模式单元，通俗来说就是，想提取什么内容，就在正则中用小括号将其括起来

### 案例2



## 基础3

贪婪模式：尽可能多的匹配

懒惰模式：尽可能少匹配，精准模式

默认贪婪模式

如果出现以下组合，则表现为懒惰模式

*?

+?

### 案例三



## 基础4

模式修正符：在不改变正则表达式的情况下通过模式修正符使匹配结果发生修稿

re.S	让也可匹配多行

Re.I	让匹配时忽略大小写

### 案例4



## XPath表达式

/	逐层提取

test()	提取标签下面的文本

//标签名**	提取所有名为**的标签

//标签名[@属性 =  'XX']	提取属性为XX的标签

@属性名	代表取某个属性值